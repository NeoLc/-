说道封装，人人都知道它的特点是隐藏了内部实现细节。

大到系统架构中的层是一种封装，再小一点的模块也是封装，再小一点的类也是封装，再小一点的函数也是封装，再小一点的变量也是封装。

封装很好的完成了代码实现和代码意图的分离，大大的节省了我们理解系统和使用系统的时间。

这是封装的一大好处。

除此之外的封装还有隐藏信息带来的安全性，功能聚合带来的专一性、低耦合等等。

1、封装记录





将保存数据的普通数据结构（eg：map类型），抽象为一个数据类，这是经常使用的手法，没有特别好说的。

2、封装集合



当作者介绍一种重构手法时，我们最好思考下，它是用于那种“坏代码”。

说实话，对于本小节介绍的内容我比较迷糊，但是感觉也不是特别重要，所以写不出东西就算了。

3、以对象取代基本类型

在现代的面向对象编程语言中，几乎万物都是对象，字符串被封装为string类型，数组被封装成Array类型，甚至基础int、float也可以封装成对象类型。



核心思想还是对数据和数据操作的进行封装。

4、以查询取代临时变量



这在前面的章节重点介绍过，越是作用域大的变量，越要对其进行严格的封装。
全局变量如此、静态变量如此、成员变量如此、甚至局部变量也如此。
通过函数，而不是直接访问，来获取该值，好处多多，在第六章有过介绍。

书中所列举的有些重构手法，对于现在程序员来说几乎是常识，不知道是不是因为本书比较老的缘故。

5、提炼类

相较于作者花那么多章节介绍重构手法，我更希望作者大量的举例，深入的探讨下，什么是垃圾代码。



我对提炼类的理解是，将一个类减负，将它核心之外的能力，拉取出来，疏解“非首都”能力。
如果不这样做，一个类会变的越来越庞大，越来越负责，责任越来越不明确。

这背后的思想是：类应该是责任明确、责任单一的抽象体，就像一个函数不应该做多件事一样，类也不应该做多件事。

6、内敛类

我的理解是：将多个类合并成一个类。

之前说过，封装是一个广泛的概念，上到层，下到变量都包含了封装的思想。

那么封装的重构手法中，适用于小颗粒的重构手法，往往也同样适用于大颗粒。

第六章提到的提炼函数/内敛函数、提炼变量/内敛变量，直到本章节的提炼类，内敛类。

底层的思想都是一致的：实现和意图的分离，让封装后的对象表达能力更强。

比如一个类的责任是表示x坐标，一个类的责任是表示y坐标，两个类的责任感觉都缺少点什么，这样不如将二者合一来得完整。

或者是散乱的类比较多，先将它们合并成几个大类，再根据责任，划分成结构小类，让类的布局更清晰。

总而言之，就是无论是提炼还是合并，目的都是明确责任、单一功能、意图实现分离、更强的表达能力，更好的可读性。

想要做到这点，办法是多想，想的越清楚越好。

7、隐藏委托关系



不看内容，光从上面这张图，可以大概猜到作者的意图，然而在java语言中，类似这种委托关系，比比皆是，不好说哪个对哪个错。
我好像曲解了作者的意思，它封装隐藏的是委托or代理类，让使用者不用感知到它们，这是理所当然的手法，也经常使用。

说到封装，什么是封装？封装的基本特征时隐藏实现细节，那么这样说，变量是封装，封装了地址、类型、数值等信息，函数是最常见的封装，它封装了处理过程，

类也是一种封装，它封装了数据和数据的操作，模块也是一种封装，它封装了一系列的类，架构层也是一种封装，它封装了一系列的模块。

封装的一大特征时隐藏细节，这意味着每个被封装的模块，因为都隐藏了内部的实现，所有对彼此的感知了解就非常少，耦合自然而然的就降下来了。

这样一个模块的变化，对另一个模块的影响就变的很小，这对于代码的修改有非常大的好处。

重构的目的有两个，一是提高代码的可读性，另一个是降低代码的修改成本，封装很好的达成了这两个目的，可以说封装是重构的最核心手法（甚至没有之一）。


8、移除中间人



这是隐藏委托的反操作，为什么会有反向的重构呢？一种重构手法的背后，意味着作用的代码是“坏”的，因此我们需要通过该手法“纠正”它。

而方向的重构，不是把已经纠正的代码，再把它变成“坏”代码了吗？

其实之前的章节介绍过很多的正反重构，例如：提炼函数/内敛函数，提炼类/内敛类，之所以有反向重构，是因为正向重构的结果不一定都是好的。

例如：提炼函数可能会产生大量的中间层，无组织的函数，反而让代码阅读变的困难，此时就需要反重构 - 内敛（合并）函数。
例如：内敛类可能产生臃肿的类，内部职责混乱，逻辑复杂，难以厘清，此时就需要反重构 - 提炼类。

当出现过度的正向重构，或者失败的正向重构时，此时就需要反向重构出场了。

例如本小节中，当委托类变的很多时，用于内部获取委托对象的委托函数也会变多，中间层变宽变厚，这和过度提炼函数是一样的问题，此时就需要反重构了。


9、替换算法



上面的示例看，下面代码的可读性并不比上面的好，例如：正则表达式会影响阅读性，而且find返回值是啥？参数是啥？include是啥功能？
candidates为空，include会抛异常吗？people为空find会抛异常吗？这些都是需要额外考虑的事情。
等等这些都会影响可读性，不熟悉这些API的人，修改这些代码钱，可能要搜索下它们的用法才能具体知道它们的作用。

所以下面的代码挺“高手”，上面的代码挺“小学生”，但是我还是比较喜欢白开水一样的代码，读起来太容易了，改起来也容易了。

作者想表达的意思，有更好的、更简单的方案可以代替你的方案，比如用语言自带的算法库甚至第三方库来替换你实现的部分算法逻辑。
它们更加安全、简洁、方便，所以在实现一个功能之前，先看看是否已经存在了较优的方案。
