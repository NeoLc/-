我对于类和继承没有太多的想法，这主要是因为我从来没有写过大型复杂的程序，这无疑是挺可悲的一件事。


1、函数上移

函数上移的意思，是将两个子类中相同的成员函数，上升到基类中，这样可以避免重复代码。

为什么要避免重复代码？这里面作者解释的非常精彩。

因为只要你的系统中存在重复，那么必然存在这样的风险：你只修改了其中一个，却忘记修改了另一个！
代码一样，则功能必然也一样，一般来说，你修改了其中移除，则必然应该修改另一处。
这个风险会让让重复代码成为bug的温床。

这种说法刷新了我对避免重复的认知。

我一直觉得复制黏贴重复代码，而不是提炼函数，使其可以实现复用，会让人觉得“小白”、“菜鸟”、“不好看”等等。
从来没有从bug的角度考虑过重复代码的坏处。
这样看了，避免重复的主要作用是：消除只修改一处，却忘记修改另外一处导致的风险。

我非常喜欢这种刷新我的认知，让我的认知进行升级的知识，very good！

通过将成员函数上升，来避免重复，好像挺简单，但是实际操作起来可能会很麻烦。

比如：两个函数只是90%类似呢，其中还有一些细节不一样呢？
比如：两个函数92%一样，但是其中一个依赖自己的成员变量或者外部函数、外部变量怎么办？
比如：两个函数95%一样，但是两个函数的参数个数不一样怎么？或者返回值不一样怎么呢？
比如：两个函数98%一样，但是一个抛异常，一个抛异常怎么呢？

这些问题处理起来可并不轻松哦。

2、字段上移

既然类中的函数可能重复，那么类中的字段当然也可能重复。

我们把子类中功能和用法基本一样的字段上升到基类中，从而避免重复。

3、构造函数本体上移

前面说过通过函数上移，避免子类成员函数的重复。

这里面有个特例，析构函数也是函数啊，如果子类的习惯函数有很多重复内容怎么办？

析构函数这么特殊，又没法把它上移啊。


书中的解决方法是：把析构函数函数中各子类公共的、重复的语句，上移到基类的构造函数中。

好像也没啥。。。


4、函数下移

在第十一章，讨论过反重构，结论是：当重构手法用错了场景，或者场景对了，但是手法用错了，代码可能越重构越糟糕。
因为重构也是有成本和代价的，成本付出了，但是好处没捞到，不就是偷鸡不成蚀把米，费而不惠了吗。
这种情况下，最好先实施反重构，先“还原/撤销/回退”原来的修改，再仔细想想应该怎么重构。


前面说过函数上移是为了消除重复，但是如果一个基类又很多个派生类，但是其中只有两个子类有重复的成员函数，
这个时候你再使用函数上移的重构手法就不合适了，如果你的同事已经用了，那么你应该使用反重构，再回退过来！

5、字段下移

和前面函数下移同样的道理，如果某个字段只被少数几个子类所使用，那么该字段不应该放置在基类中。

6、以子类取代类型码



我可以大概的明白的作者的意思，底层的意思还是职责抽象分离，一个类不要包含太多的多层意思，不同职责分开，用不同的结构来处理。

上面的代码是典型的多态的实现，这种情况下如果不同的type，每种“employee”的各种处理都不尽相同，那么分离成不同子类是非常合理的。

如果不同的type下，内部成员函数的处理方式都几乎一样，那么多态的手法反而“惠而不费”。

7、移除子类




移除子类是以子类取代类型码的反向操作。

派生子类不是一个低代价的活，它会明显的增加代码的复杂性。

我们需要权衡付出复杂性代价所获取的收益，如果收益压根就抵消不了复杂性增大的代价话，派生子类是一个得不偿失的重构手法，此时应该执行反重构进行回退操作。

子类什么时候会失去它的价值呢？

子类的作用除了继承父类，复用父类实现，避免编写重复代码，还有实现多态之外，没有其他的价值了吗？

继承父类，实现多态，背后的思想是什么？这种语言机制是为了解决什么问题而存在的呢？

书中的说法是对数据结构的多样性和变化提供支持。

我觉得换种说法，是为了同一类问题的多样性和变化提供支持？不同的子类，可以实现多样性，多态，可以实现不同的变化，不同的处理方式。

作者的说法是，如果问题的多样性或者变化不存在或者变少了，那么子类存在的价值也就不复存在，最起码大大的降低了。

这个时候，子类就应该被移除掉。


8、提炼超类

很简单，将两个子类重复的地方抽取处理，提炼成一个父类。提炼超类是避免重复的一个手段。


不过这里面也有一个问题，最常见的public继承表达的是“is--a”逻辑关系。

如果逻辑上不存在这种关系，使用public继承是不太恰当的。私有继承表达的是“has-a”逻辑关系，貌似可以解决这个问题，但是《effect c++》不建议使用私有继承（我忘记为啥不推荐了）。

不过我觉得，如果两个子类存在重复的地方，则提炼出来的父类，与子类在逻辑关系上是合理的，那么提炼超类是一个“有赚头”的活。


9、折叠继承体系



总感觉很多小节的名字起得挺糟糕的，重构的作者一直在强调命名的重要性，然而重构这本书翻译的内容，名字却其的一言难尽。

折叠继承体系，听起来挺唬人，从名字也看不出到底要干啥。

其实做的事情很简单，就是将子类和父类合并到一起，那干嘛不叫：合并父子类呢？

10、以委托取代子类

这一章节的内容让我理解起来有点困难了，我关于继承方面的编程经验太少了。

本小节的内容和《effect c++》中继承的章节有很多的内容都一样，例如：优先使用对象组合而不是继承。

继承可以消除重复，实现代码复用，去除重复代码，虽然可以消除修改一处，但是忘记修改另一处的bug风险。

但是同样是有代价的，代价就是修改了一处，会影响复用它的N处，天下是没有白吃的午餐。

而且不可否定的是继承实实在在的提高了代码的复杂性，我想大家都有被android复杂的继承体系所支配的恐惧。

其次继承也是有一些短板的，比如有人这个基类，而我们需要“年轻人”、“老人”、“穷人”、“富人”这四个子类。

代码实现中如果把这四个类都挂在人这个基类下，总感觉怪怪的。尤其是这四个子类的内部成员函数可能完全不同。

此时可能需要在“年轻人”、“老人”之上再提炼一个基类，在“穷人”、“富人”之上再提炼一个基类，再这两个基类之上，才是人这个基类。


我没法给这种问题抽象表达出来，但这种问题确实存在，作者人为可以用委托来解决这个问题。

简单老说就是将一个类对象作为另一个类的成员变量，形成一个“has-a”或者“impl …by..”的关系，这在《effect c++》中有过介绍。

我想大家编程中有意无意都大量的使用过这中技巧。


大家都会，但是作者把这种技巧解释出来时，大家反而听不懂了。挺无语的。


11、以委托取代超类

以委托取代超类，不如以委托取代继承这个名字来的更加容易理解。

如果你知道《Effect C++》中关于“is-a”和“has-a”的继承关系，那么理解本章节对你来说会变得非常简单。

作者举个一个技术发展早期，错误使用继承的实例，我觉得挺不错的，如下：

Class Stack : public List，作者的意思很明确，希望通过继承这种机制来复用List的功能，使用List作为数据基地，来实现栈。

但是现在我们可以很明显的发现其中的问题，就是Stack和List的之间的继承逻辑有问题。

Stakc is a List ? 这明显不通顺，它们这种正确的关系是:Stack has a List。

而要想实现has a的关系，要么通过私有继承，要么通过委托，私有继承在《Effect C++》中介绍过，只是极少数的和效率相关的特殊场景才需要用到私有继承。

其他需要表示“has a”关系的，都是最好使用委托。


所以本小节作者想表达的意思，我猜是，如果当前的超类和子类不是“is -a”关系，而是“has-a”关系，那么你应该使用委托关系来取代集成关系，将基类对象退化为普通类对象，然后内嵌到子类中去。


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


本章节看的非常快，原因如下：

+ 自己继承方便的经验比较少，对本章节的内容没有太多的触动。
+ 本章节的内容确实有点水：例如：1、2、3、4、5、6、7、8、9
+ 有些内容和《Effect C++》重复，属于已掌握的内容，所以看的比较快，比如：9、10、11。


但是本章节还是有一个有用的内容，比如：对于避免的重复的解释，虽然只有一句话，但是却刷新了我对它的认知，再次点赞。


挺遗憾，花费了2~3个小时，看完本章节，除了温故之外，好像没有知道啥新的东西。
