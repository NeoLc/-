1、变量命名

给变量起个好名字的好处很多，可以列出7、8条，但是大家肯定记不住，所以只说，其中我认为的最重要的两条。

第一：当你没法给你一个变量、函数、类、模块起一个好名字的时候，这背后往往隐藏了很多问题，需要引起你的警觉。
    - 你对需求不清楚，或者没想清楚。
    - 你的设计并不清晰明确
    - 你对功能实现没想清楚
    - 你对某段代码的作用没想清楚
    - 总之，你的头脑不清楚。

起个好名字，可以促使你更深入、更清晰的思考代码的作用，从而避免bug的产生。


第二：提高代码的可读性，可读性的提高的好处非常多，易于维护、扩展、升级等等，可以大大的减少你的时间精力。

说可读性提高还是给人一种模糊的感觉，大家可以想一想，阻碍我们阅读代码速度一般是哪些因素？ （排除对语言语法不熟悉的情况）

换句话说，花时间看代码，时间都花在哪里了？看代码看的是什么？ -- 看的是实现！需要根据代码去看功能怎么实现的。

要去猜、要去想，要去推导，这个变量是干嘛c的，这个分支是干嘛的，这个函数是干嘛的，这个类是干嘛的，输入是什么，输出是什么。

如果一个函数名字起得好，我们压根不需要跳转到函数的实现，去一行行的看函数的内容。

如果一个类的名字和接口的名字起的好，根据这些名字，我们就能把它的功能猜的大差不多。

名字起的好，我们从名字中就能获取很多有用的信息，这要比去一行行的看代码，再去猜、去想、去推导、去试它有什么，要快速的多。

2、重复代码

重复代码的坏处人尽皆知，但是去除重复代码的技巧，掌握的人却不多。


3、过长函数

是个人都知道，绝大多数情况下，函数越长，越难以理解，可读性越差。PS：然而android源码中/linux内核中，这种超长函数比比皆是。我们它们是想保持逻辑的完成性吧。

解决过长函数的方法也很简单，就是将其分割成多个子函数。

那么什么时候应该去分割一个函数呢？？ -- 书中给出的答案是：注释冲动。

当你需要用注释解释一段代码时，你就要意识到，it's time，需要把这块代码单独提炼成函数了，方法是把注释抽象成函数名，把代码块变成函数体。

函数分割有好有坏，不要一味的提炼函数。

好处很明显，可以提高可读性，函数名具有解释意义，可以减少代码阅读量，也可以避免过长函数，同时函数还具有封装复用功能，可以避免重复代码，个人感觉最大的好处就是这两个了。

坏处也很明显，首先它将一个完整的作用域分割成了多块，这样就需要考虑不同作用域之间的通信问题，常见的方法是函数传参、返回值、或者全局变量，但这还是给我们带来了额外的麻烦和成本。

除此之外，新增了额外的状态，比如入参合法性的判断，返回值的判断，入参是传值还是传引用，返回值的拷贝问题，资源释放问题，多线程场景下是否可重入的问题。

当然还有函数调用的开销，当前现代编译器通过内敛或者优化可以大大的缓解这一问题。

还有，函数的提炼，可能会导致阅读时频繁的代码跳转，还不如把相关逻辑放在一起来的方便。

所以提炼函数，优点很明显，缺点也很明显，需要仔细的权衡。


4、过长函数列表

怎么解决函数列表过长的问题？？ - 最常见的方法是将多个参数封装为结构体。

除此之外还有什么办法吗？


5、全局变量

全局变量之所以臭名昭著的原因在于，它所导致的bug，非常难以定位，教训惨痛，因此让大家对它望而生畏。


6、可变数据

它和危害其实和5强调的一样，A变量，在作用域的多个地方引用，任意一处对该数据的修改，都可能会影响其他任何一个使用它的地方。

所以变量的作用域越小越好，联系(关联)耦合越少越好，只读最好，尽可能的减少状态。

比较糟糕的例子是，一个可变数据在再多个函数或多个模块"流窜"，每个地方都可以读取和修改它的值，一旦出了bug，非常难以定位。

如何最低的降低它的影响，书中后续章节会有介绍。


7、发散式变化

A的修改和变化会影响B和C，B和C的变化又接着影响D、E、F、G，影响逐渐的发散开来，这种情况下软件的修改变的异常困难。

在不同的模块，不同的类，甚至不同的函数之间，应该有意识的建立一些“防火带”，避免星星之火燎原之势。


8、霰弹式修改

该问题更多是代码实现或者设计上的问题，A的一点小变动，会导致很多分散的小点都需要修改，这是我们很熟悉一种问题。


9、依恋情结

该标题讲的是模块划分的边界，模板化和去耦合是老生常谈的事情，但是模块和模块之间的划分边界是什么，一个函数应该划到A模块，还是应该划到B模块？

某个结构体，或者数据对象，应该放在A模块，还是放在B模块？

书中给出的方法是，看看它和哪个模块交互的更加频繁(次数)、深入(数据量大)，就表示该对象更加依恋某个模块，就让有情人终成眷属吧。

10、数据泥团

data mass是挺常见的一个问题，可以让我们联想到堆在一起的很多个变量。

PS：本书有个可以优化的地方，代码的坏味道能否举几个真实的例子，本书的该章节一个例子都没有。

11、基本类型偏执

这个问题有所了解，例如：用两个float、float变量来表示经纬度，而不是创建一个经纬度对象，或者用用两个float表示坐标，而不是创建一个坐标对象等等。

基本类型偏执一方面可能导致数据泥团，另一方面可能带来可读性的问题。

12、重复的switch

没有看明白这个小标题想表达的意思，如果有个例子就好了，尤其是switch和多态的联系，更是听的云里雾里。

13、循环语句

书中认为循环这种语言基础设施是老古董，可以通过“管道”操作来代替它，说实话，我是头一次听说这个东西。

14、冗赘的元素

当一个函数的函数体越来越薄，使用者越来越少，调用次数越来越少，那么这个函数是时候消亡掉了。将其声明为inline函数或者lambda函数，甚至直接将其函数体放置到调用侧。

同理，类也一样。

这个问题挺常见的，属于已知的坏味道，读本书的目的是希望能培养出代码的品味，一眼看出哪些代码写的好，哪些代码写的不好，同时应该怎么样修改。

15、夸夸其谈通用性

这个问题还有个别名叫做：过早优化，过早兼容，过早适配，多度防御。往往出现在有些点经验，看过些书，但是其实是个半吊子的开发者身上。 -- 说的就是我自己。

在实现中去考虑一些不可能出现的场景，或者是真实使用场景中几乎不会出现的场景，或者是小概率出现的场景，或者是某些特殊的场景。

甚至会去实现一些需求之外的功能，美其名曰是为了软件的稳定性、通用型、将来的扩展性等等。

然而在软件的真实使用场景中，这些“通用性”的代码分支几乎不会走到，或者很少走到。 

过度的某些考虑特殊场景/情况，脱离实现，人为的增加软件使用场景，使得软件的复杂度上升，变的难以理解。

还有一种是对各个错误场景进行兜底，也不管它的出现概率。过度防御，使得代码又臭又长。


仅根据当前需求设计软件，同时把将最大程度的让架构足够灵活和稳定，不要人为的给自己加戏，加需求。

注意：灵活的代价可能是复杂度上升，这一点要做好权衡。

满足需求，即质量，不要去做多余的事情。2/8原则要记住。

16、临时字段

有些成员变量，静态变量的创建往往仅仅是为了应对某些很少出现的特殊情况，但是成员变量、静态变量又给人一种通用性的感觉，这种歧义会增加人的理解成本。

书中后续会给出一些解决方法。

17、过长的消息链

我理解的意思是过长的函数调用，调用A想要获取结果，内部会调用B、C、D、E、F、G，这种一连串的函数，其中任意一个变化或者改变都可能会导致问题。

其实就当前的列出的17条代码坏味道，他们的核心关键词有几个：修改、变化、影响。

当前我还办法说清楚这些，是因为我对其的理解还不够深刻，没法给这17条进行分类，并说清楚其本质。

例如：你怎么理解封装，如果你没有深入的思考过这个问题，你只能说出书本上对它的描述：对象的基本特征之一就是封装，封装对外部隐藏了实现的细节。

某种意义上，计算机中封装无处不在，因为抽象无处不在，抽象的副作用就是封装，变量是内存块的抽象，变量隐藏了内存块的地址信息，将一个16进制的地址，封装成了一个有类型，有名字的变量。

类也是一种抽象，毫无疑问，类也是一种封装。

抽象和封装到底啥关系呢，先有抽象，还是先有封装呢？，必然是先有抽象，没有抽象，封装的内容是不可知的，封装无从谈起，封装内容的多寡，取决于抽象的对象，也取决于抽象的高低，
没有封装，抽象无法实现的，只能是一个概念，无法真正落地使用，两者相互依存，jiaobulimengmengbulijao，类似伴生关系？？ -- 能举个生活中的形象解释它们吗？

18、中间人

我理解的意思是，一个类的大部分对外接口，都是通过委托了其他的类实现，该类只是一个“不干实事”的壳而已，这在Android中还是比较常见的。

我个人编程还没遇到这在情况（代码还是写的太少），书中给出一些建议来解决这个问题，后续会有介绍。

19、内幕交易

又是中间人又是内部交易，搞定像无间道似的。

本小标题介绍了一些降低耦合的方法，我反正是一个也没看懂，后续详细介绍的时候再看看吧。

20、过大的类

超大的类在Android中貌似是挺常见的一件事。

本小标题，建议将一个类减负，精简它的结构，将它内部的一些字段和函数精炼提出处理（这样好处明显，坏处也明显），就好像北京有个雄安疏解非首都功能一样。

精简一个臃肿的类，这是常识，我们需要知道的是技巧和原则。

21、异曲同工的类

看了一遍，没看懂讲的是什么。

22、纯数据类

同样没看懂，对于纯数据类的操作有什么需要注意的点。

23、被拒绝的遗赠

当子类继承了父类，但是不想继承父类的某些接口和数据，该怎么办，我没有遇到过类似的问题。

24、注释

什么时候应该写注释呢，当一段代码存在一些待fix的bug，存在一些TODO，存在一个NOTE，此时是需要写注释的，除此之外的如果还存在注释，说明你的代码需要重构。


************************************************************************************************************************************************************


本章节列举了24个代码的坏味道，因为我的编程经验比较少（挺惭愧，虽然工作了7年多，但是还是没啥经验），其中一多半都没有什么心得体会。

同时也分不清问题的重要程度，哪些是最坏的味道，哪些是淡淡的臭味，也分不清问题概率高低，哪些是大多数经常犯/经常出现的错误，哪些是很少出现的问题。


对于这24个问题进行抽象，提炼出更加本质和底层的逻辑就更加做不到了，说明对于代码的重构，我是没有太多的经验的和深入思考的。

我想即使没有看过本书的人，只要重构的经验足够丰富，是可以自己写出重构的一些原则，重构的常见问题和解决方法的。

我能想到就是最基本的原则，就是重构前要有充足完备的测试，还有烂大街的高内聚，低耦合，消除重复，但是具体的方法手段，又说不说出个理所然出来。
