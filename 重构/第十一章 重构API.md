API设计的重要性不必多少，甚至有学者专门写了一本怎样设计API的数据。

甚至有位阿里的P9说，看明白一个系统设计的API，就能了解这个系统一半了。

API的重要性可能一般。

API是一个模块对外暴露的窗口，如果模块是肉的话，那么API就是就是连着不同肉的筋！

1、将查询函数和修改函数分离

从重构API的前言介绍看，查询函数处理的是只读数据，修改函数处理的是可变数据，处理的是不同类型的数据，所以最好用不同的API区分它们。

我想作者想要表达的意思，还是明确职责划分，职责单一在多数情况下，总是好的。

具体看了作者描述的这样做的动机，没明白其中的“副作用”指的是什么？

我个人的理解，函数的执行的目的，抽象来说有几种：

+ 单纯的执行命令，一个函数执行之后，整个系统发送了一些变化。

+ 单纯的获取数值，通过函数返回值拿到一些数据，没有任何副作用。

+ 即执行命令，又有副作用，例如：返回值是执行命令的结果。

上面的总结是我根据作者描述的“命令和查询”分离的说法推测的，不保证正确性。


作者的建议是，当一个函数既有副作用（命令），有要返回值时（查询），最好将命令和查询两个操作分离开。

这种做法，我隐约好像试过，但是没有特别大的体会。

2、函数参数化

这个技巧没有啥特殊之处，就是合并两个逻辑类似的函数，其中不一样的地方抽象为函数参数传入函数。

非常常见的技巧，只是作者给起了一个名字。

3、移除标记参数



从上图的示例就可以猜出本小节想表达出来的意思。
其实本质上还是要想清楚，说清楚，写清楚一个函数的功能作用。
在弄清楚它的作用之后，这个函数是否应该重构，应该怎么样重构，其实差不多可以做到心里有数了。

作者提出了一个叫做“标记参数的”，它很好理解，你一定见过。
如果函数根据参数的不同，执行函数不同部分的逻辑，那么我们可以认为这个参数是一个“标记”参数。
作者还加了一个限制，标记参数必须是一个字面量值（eg：“123456”，123456等等）。

我们没必要死守着作者给出的限制，重点是理解，标记参数为什么不好呢？
作者的看法是，根据标记参数的不同，函数的执行部分不同，那么不同参数，这个函数的表现就不同喽？
那么不同参数，函数的执行差异到底在哪里呢？ -- 不知道，最起码光从API，你是看不出来的，只能猜。

我并没有太深的理解作者的意图，也不是特别认同作者的观点。
因为带标记参数的函数，某种意义上来说，挺像第二小结的函数参数化，我感觉要比拆成好几个函数要好。

不过它们之间还是有区别的，在第二小节中，无论参数是什么，执行的函数体基本是一样的，只是其中的一些细节稍微不同。
而本小节中，标记参数的不同，执行的函数体很可能压根就不一样，感觉像是根据标记参数的不同，执行不同的函数体一样。

不好说，那种更好，可以在阅读优秀源码时，留意这个问题。

4、保持对象完整



这也是函数使用上的一些小细节，有时候觉得，函数中只使用了对象的个别几个成员变量，
把整个对象都传递进去有点“浪费”，所以干脆就传入这两个成员变量的值就好了。

从上面的示例看，作者好像不太赞成这种做法，虽然我经常这样干：）

作者认为直接传入对象，有下面几个好处：
+ 可以方便应对后续的变化，这样如果将来函数需要该对象的其他字段时，就不需要修改函数了。 
	->  这会不会犯了过早优化的毛病？-> 夸夸其谈通用性 -> 坏代码的味道：）
+ 可以缩短参数列表的长度。
	-> 但是又有缺点，这样阅读者会以为该函数依赖于整个对象，而不是仅仅依赖于对象的某各字段而已，造成理解上的误差。
	
作者给出的两个理由都很好，但是反驳起来也挺简单。
当然作者还从依恋情节整个代码坏味道的角度，解释了保持对象完整性的理由。

不过我个人感觉，这个还是要视函数的使用上下文而定，不要教条的照搬作者的手法。

5、以查询取代参数

关于查询，作者介绍了很多次，可以说是情有独钟。
从职责的单一性(命令/查询)角度建议使用查询，从数据类型的角度建议使用查询，从可变数据封装的角度建议使用查询等等。

这个小节介绍的内容正好戳到了我的点，我在实现实时调参工具时，就遇到过类似的问题。

具体就是：如果在函数的内部就可以获取函数参数的值，那么还需要传入这个参数吗？

作者认为，省略整个参数，而在函数内部获取这个参数值的好处如下：
+ 参数变少，API函数更加容易理解，更漂亮，也更方便使用。 -- 这是最大的好处。
   尤其是好几个函数，都有一个参数的时候，如果能隐藏的话，就相当于隐藏N(函数个数) * 1个参数了。
+ 在函数内容通过查询获取该值，该值的维护责任就转移到查询函数了。

不过我个人并太认同这种方式，当然作者也说明这种做法的弊端，如下：
+ 通过查询获取的值可能是可变数据，然而如果作为参数出入，那么该值很可能应该就是固定值。
    固定数据变成可变数据，这是挺大的一个风险，而且问题挺难定位。 --- 这是最大的坏处。
+ 而且隐藏了这个参数，可能还不利于使用者更好的理解API。封装是好事，但是过度封装就不好了。
+ 最后，作者也说了，通过查询获取值，可能会让函数额外的增添对外依赖的负担。

所以，到底应该要不要以查询取代参数，我自己也蛮犹豫的。
如果这个参数只只读的，而且对于理解API也无伤大雅，且这个参数的查询函数足够简单，那么使用查询代替参数确实是利大于弊的。

6、以参数代替查询

上小节刚建议以查询代替参数，这小节就建议相反的以参数替代查询。

我猜测作者其实还是挺怕大家教条的把某种重构手法照搬到所有场景，所以特意给出“反重构”的手法。
我想主要目的是触发的大家的思考，明白没有100%正确的重构手法，要视环境而定。

这里作者再次提到了查询替代参数的主要坏处：使得函数的依赖性变强，这种依赖性可能会导致一些问题。
使用参数代替查询可以移除这种依赖性，但是又增加了API使用上的复杂性，调用者需要考虑传入参数值的合法性。

无论是以查询替代参数，还是以参数替代查询，都有优缺点，需要自己权衡。

7、移除设值函数



本小节比较简单，作者想表达的意思是，如果一个成员变量是非可变数据，那么它唯一赋值的地方就是在构造函数，在构造之后该数据就应该是只读的。

这听起来挺理所当然，好像大家都是这样做的，其实不然，很多程序员对于数据的可变性和只读性的重要性认识并不清楚，它们知道只读的好处，但是并没有刻意的去为只读创建一些条件。

在设计类时，应该想清楚那么成员是可变的，哪些成员应该是只读的。

8、以工厂函数取代构造函数

工厂函数一般用于抽象类中，用于返回各式各样的子类。

作者认为构造函数比较特殊，做不到把它当做一个普通函数那样对待。

比如构造函数没有返回值，不是void的那种没有返回值，而是在结构上压根就没有返回值。

比如构造函数不能像函数那样直接调用，而必须使用new这种特殊的方法才能触发。

比如构造函数一般禁止抛出异常，而函数可以随意的抛出异常。

比如构造函数必须和类同名，名字没法像普通函数那样可以随意起。

比如构造函数只能返回对应类的实例对象，而不能返回它的子类实例。PS：这好像不是一个缺点，但是对会实现多态造成一些麻烦。

比如构造函数在声明一个对象时，构造函数会隐式的调用，没听说普通函数还有这种用法。


总之构造函数名为函数，但是非常特殊，无论是结构上，还是用法上，都和普通函数大相径庭。


作者提出通过通过封装构造函数，抽象出一个具有特殊作用的工厂函数来代替构造函数，这样的好处挺多：

+ 根据参数的不同，可以返回任意的实例对象，无论是父类还是任意子类 -- 这也是工厂类的最大用处。
+ 函数名字可以随意取，可以使用一个表达能力更强的名字。
+ 可以返回值判断，可以异常机制。
+ 在使用上，工厂函数和普通函数没有任何不同。


所以在面试时，你可以出一道题，使用工厂函数和直接调用构造函数有什么不同？

最大的不同在于构造函数只能返回单类对象的实例，而工厂函数可以返回多类对象的实例。
剩下的就是一些关于构造函数和普通函数的在结构、用法、机制上的区别。


这里注意，工厂函数一般只在特定的模式下使用，不要一股脑的用工厂函数取代构造函数。

9、以命令取代函数

在前面的小节中，作者有提到过函数的作用分为命令式、查询式、命令查询混合式，作者觉得第三种方式是不好的，最好做到命令和查询的分离。

本小节中的命令和前面提到的命令和查询不同，它指的是“命令对象”，它本质是一个类对象，只不过这个类专门封装了该函数。

这很像C++中的仿函数概念，作者提到命令对象的好处在于灵活性，它可以提供除了该函数之外，还可以添加一些附加的功能。

作者觉得这种做法和GOF中的“命令模式”比较相似。我对设计模式没啥研究，作者说像那就像吧。


我个人觉得命令对象是类和函数一种中间状态，命令对象是一种特殊的类，函数是一等公民，而普通的类，对象是一等公民。

这种以命令取代函数的做法，我个人没有尝试过，貌似也挺少见过，我想挺难区分一个类是用于命令对象还是单纯就想封装一个函数而已。


10、以函数取代命令

好家伙，前面刚说过以命令取代函数，这里反手来了一个函数取代命令。

命令取代函数的好处在于它的灵活性，除了函数本身外，还可以额外添加一些附加功能，但是坏处在于额外的增加了复杂度，在实现上还有使用上都比较麻烦。

作者认为一个函数比较简单，那么把它封装成一个命令对象，是“费而不惠”的，即没有灵活性，还额外的增添了复杂性，此时应该执行反重构，让它重新变成一个函数。


可以看到，执行反重构的场景是：原有的重构手法即没有得到好处，反而惹得一身骚，或者说是偷鸡不成蚀把米，或者说是费而不惠。

再解释下，每种重构手法都是有成本和代价的，我们付出了这些成本是为了获得更大的好处。

如果重构用错了场景，或者重构手法使用不当，造成了既付出了代价，什么好处还没捞到，结果反而变得更糟了。

此时反重构就出厂了，它类似一种“回退/撤销”的功能。


------------------------------------------------------------------------------------------------------------------------------------------------------------------------

本章节有用的内容依然不是特别多，不过却让我对反重构（10）、仿函数（9）、工厂函数（8）、可变数据（7）、查询还是参数（6）、标记参数、以及函数有了更深的理解。

不过我不知道这些理解，随着时间的流逝，会不会慢慢遗忘。

如果是的话，那么这书算是白看了，还是那句话：没有经过深度思考得出来的东西，是无法留存在大脑中的。
