前面的章节有针对函数、模块、数据结构等重构的介绍，本章节着重探讨了对条件逻辑的重构。

1、分解条件表达式




条件分支的复杂性是整个软件圈复杂度的重要组成部分，条件逻辑复杂，则软件必然也会复杂。
降低复杂的手段还是老一套，适当的抽象和封装。

将判断语句抽象为函数，将分支的处理逻辑抽象为函数。
这样可以清楚的一眼看出抽象的判断是什么， 每个分支做的事情又是什么。

没有特别出奇的地方，相当于提炼函数在条件逻辑下场景下一个应用。

2、合并条件表达式



提炼函数在逻辑上有个挺大的问题，就是函数和函数之间是完全平等的关系。

光从罗列的一些函数中，你是看不出A函数只是为B函数服务的，C函数视为D1、D2、D3函数服务的。
E函数其实是F函数的一个“内部子函数”等等，你很难看出，那几个函数的组合其实是某一个逻辑整体。

因为函数完全可以分散到文件的不同的位置，甚至不同文件中，虽然有一个“中心”函数描述了多个函数的组合关系。
但是提炼函数还是给人一种割裂、分离的感觉。

这种平等的关系，破坏了整体的逻辑，它们原本是一个逻辑整体，不同部分之间是有逻辑关系的，
但是将它们拆解为一个个函数之后，函数之间从语法上是没有所谓的逻辑关系的，是完全平等的。

类是有逻辑结构的，你可以通过类的结构，识别出两个类直接有关系（父子/兄弟），或者完全没有关系。
而函数是没有逻辑结构的，你无法通过函数的逻辑结构判断两个函数直接是否有关系，只能通过具体看这两者的实现才能看出关系。

虽然lambda表达式的出现，缓解了这一情况，但是函数天然的割裂性、分离性还会给人造成一些困扰。
函数有太多的优点，但是函数未尝没有缺点。


在本小结中，将多个逻辑上相近的判断合并为一个函数，也是我们经常使用的手法，

但是如果有8功能类似的函数，每个函数都需要做入参判断，但是每个函数的参数都不同，难道需要8个check函数吗？
如果提炼出8个check函数的共性，函数的数量又会进一步的上升。

这种一个文件好多个函数，个人觉得是挺影响可读性，作者非常喜欢提炼函数，然而我个人对它持保留态度。


3、以卫语句取代嵌套条件表达式




什么是卫语句（Guard Clauses）？

这里面作者提出了一些比较新颖的概念，首先条件大多分为两种：
一种是两个条件分支都是正常行为，另一种情况是一个条件分支是正常的，另一个条件分支是异常的。

我们讨论一下后一种情况，在实际经验中我们可以知道，异常分支出现的频次要比正常分支少很多。
但是if…else…这种代码结构，天然给人一种逻辑平等的感觉，如果A怎么怎么样，不是话又怎么怎么样。
好像每个分支的都挺重要，最起码阅读者一般挺难判断出，那个分支其实更加应该被重视。

对于一些“特例”情况，可以从分支逻辑抽离出来，单独的判断它，如果为真，则立即做出一些处理，然后返回。
这种做法称之为：卫语句。

函数入参判断就是最最场景的卫语句，只是我现在才知道它的名字。

不过本章节中，作者提出的分支逻辑天然的平等性，让人难以判断那个分支更加被重视，确实值得思考。

一般的编码建议，最可能被调用的分支，放置在最前面，最不可能被调用的分支，放置在最后面。
其中特别异常的分支，单独使用卫语句进行处理。

我想这也是一个比较好的解决方案。

4、以多态取代条件表达式





咱不看小结的内容，仅仅从上面的示例看，我觉得太“小题大做”了，有点为了节省路费，结果买辆车的感觉。

因为有了管道代替循环的经历，在这里我需要警醒下自己，在你没理解高级做法之前，你会觉得低级做法哪哪都好，高级做法哪哪都不好。

就好比我没理解管道算法之前，我一直吐槽它的可读性，抛异常，返回值判断等等。

等我真的理解它只会，你又会觉得它可读性真好、真安全等等，确实是一种更加高级的用法。

但是用惯用石头砸钉子，甚至锅铲砸钉子的人，它天然会对用锤子砸钉子的方法产生排斥。

我曾经还发微博讽刺过这种行为，看看我在本小结写的第一行评价，不也是对新方法进行排斥吗？

所以，在你没有真的理解一个用法之前，不要随意的评价/批判它，还是那句话，当你对一个概念的认知水平较低时，
你对它的评价和疑问，很大概率是可笑的。

现在让我们来学习一下，为什么要用多态来替换分支，这样做的好处是什么。

我大概明白了作者的意思，这里简单的描述一下，不知道对不对。

首先作者自己也承认，对于大多数的条件逻辑，仅仅使用if…else…和switch…case就可以又快又好的实现了。
但是对于少部分的比较复杂的条件逻辑，使用多态也许是一个更好的选择。

首先我们对条件逻辑进行一下抽象，它的真正作用到底是什么？它的本质到底是什么？

简单的说，条件逻辑就是：对通样的功能下，区分不同场景，对不同的场景，分别进行各自的处理和实现。

例如：if(xxx)/switch都是用于区分不同的场景，在{}和case中进行不同场景的处理和实现。

那么还有什么语法特性可以做到效果？ -- 很显然，多态可以。

多态可以实现同样一个接口，不同种实现。
我们可以抽象出一个基类，通过它的参数，返回不同的子类，这样就做到了区分不同场景的效果。
通过不同的子类override基类的函数，这样调用该函数，实际上执行的是特定子类（场景）的实现。

如果有其他的语言特性，eg：模板也可以实现类似的效果，那么我们也可以再添加一个小结：用模板替换条件表达式。

这里还有一个问题，为什么多态实现的条件逻辑，要比if…else…和switch..case..实现的条件逻辑要好呢？
作者人为多态实现的条件逻辑更加“结构化”？我大概能体会作者的意思，但是又说不出来。
可以通过我前面描述的，函数没有结构，导致函数和函数之间的没法察觉交互关系，所带来的理解成本。

5、引入特例

本小节提到了一个和条件逻辑相关的重复代码场景，就是null的判断。
在函数的调用中，最常见的场景就是入参的检查，尤其是空值的判断更是非常频繁。

作者认为关于这部分的重复的条件逻辑，可以抽出来，这样可以降低重复代码。

其实很多的开源函数都做了这方面的工作，比如最常见的用宏来代替这部分的重复代码，或者直接用断言来检查。
作者认为如果null的判断处理多样的话，还可以单独的抽象一个对象（里面包含多个函数）来专门进行空值的处理。

6、引入断言

上一小节刚说道断言，本小节就专门介绍断言了。
断言的使用非常方便，一般用于一些绝对不应该发生的，且难以恢复的状态进行检查，有些编程语言在编译期就可以关闭它。

我个人鼓励使用断言，但是不要滥用它，什么大大小小的检查都用断言，对于一些可能导致fault级别的问题，才应该使用断言。
比较断言的不满足结果是abort退出，终止程序。

作者提出的一个更加有趣的使用断言的约束：只有当你有信心认为某个断言(判断)绝对不会失败时，你才使用断言。

-----------------------------------------------------------------------------------------

这个小结有用的东西不是特别多，但是却触发了我不少的思考，尤其是对于函数的思考，以及面对陌生知识的态度。
除此之外，还加深了自己对于条件逻辑、多态的认知。
