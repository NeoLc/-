搬移重构这个概念对于我来说有点陌生，作者说之前的重构手法，基本都是对程序元素进行增、删、改。

其中程序元素我的理解是：语句、函数、类、模块之类的代码。

举个例子：提炼函数（增）、合并函数（删）、函数更名（改）。

除了增、删、改之外，又增加了一个搬移（move）操作，用于将一个程序元素更换位置，也不知道我理解的对不对。


1、搬移函数

在软件的代码量上了之后，最让人花心思的事情之一就是代码的组织问题，如何组织这些代码，尤其当不同代码之间关系错综复杂的时候。

我个人的心得是，首先明确功能职责，想清楚软件到底有哪些功能，这些功能的具体职责是什么，然后再划分模块。

说起来像是一句废话，然而做起来却挺难，我甚至连其中的难点都说的不太清楚。


总之，搬移函数是帮助组织代码的一种的手段，将一个函数从A文件move到B文件，或者将函数从模块A move到模块B，从而让组织结构更加清晰。


我们知道软件设计的核心设计思想之一就是模块化，高度模块的代码好处多多，这里不再一一陈述。

高度模块化的特征是内部包含了联系比较紧密的函数和数据，同时这些函数和数据和其他模块关系并不紧密。


搬移函数的方法就是将一个模块中和它联系不太紧密的函数，搬移到其他和它比较紧密的模块中。可以说搬移函数是实现模块的一种手段。

是否紧密的可能不太好判断，我们可以通过调用的频繁程度，和模块数据的交互程度，和模块上下文的交互程度来判断。


上面的文字看起来写了很多，但是细读几遍，可以发现逻辑并不通顺，要是上台去讲的话，估计会卡壳。


我再总结一下：搬移函数可以提高一个模块的模块化程度，方法是将和该模块联系不紧密的函数move出去，将和该模块联系紧密的函数move进来。

听起来像常识一样简单，但是做起来不太容易。


2、搬移字段

上一小节move的是函数，本小节move的是数据结构中的字段。

程序 = 数据结构 + 算法，由此可见数据结构的重要性，坏的数据结构使用起来别扭不说，它还会隐藏程序的真实意图，往往拉长我们理解程序所需的时间。

所以如何设计一个数据结构，什么样的数据结构才是好的数据结构，这是一个值得深思的问题。我目前还没有什么特别的心得。


我个人对搬移字段的理解是，它的底层思想还是让数据结构变的更加“纯粹”，职责更加清晰明确，让一个字段去它该去的地方，如下图所示：





个人觉得，弄清楚这些重构手段背后的含义与思想，然后不断的试验这些思想，才是学习重构的正确做法。

3、搬移语句到函数

就语句搬移到函数的场景有两个：
+ 一个是消除重复，如果一个语句在不同地方多次出现，那么干嘛不将其放在函数中呢？
+ 如果将一个语句放到一个函数中，那么这个函数会变得更加圆满，为什么不这么做呢？


隐约有种感觉，是为了服务搬移这个大主题，人为的细分了一些小章节，实际这些内容和前面介绍的东西很多都重复了。

而且这些小节背后的思想都是一样的，感觉像是同一思想在不同代码颗粒度下的示例，没啥稀奇的。

而且这些方法貌似都是平常经常用到的手法，只是没有给它起个漂亮名字而已。

我有点怀疑，看完本小节之后，我个人的重构能力有增强吗？？

4、搬移语句到调用者

一开始一个函数能很好的被几个调用者使用，当随着新需求和新场景的诞生，函数的内部开始需要对一些调用者进行特别处理，也就是说函数的调用者出现了特例，

函数不再对所有调用者一视同仁，此时需要将其中的“特例”部分，搬移到特殊的调用者哪里，而不是在函数中内部迁就各种特殊的调用者。

这个小节挺不错，解决了一直以来存在的困惑，是一个任意调用者“兼容”的，瑞士军刀式的万能函数，还是一个“纯粹”的，尖刀一样，一视同仁的单功能函数。


5、以函数调用取代内敛代码

没看明白这小节的内容和搬移有啥关系，从小节名字看不就是提炼函数吗？

6、移动语句

简单一句话就是，将相互关联的语句move到一起。

有种为赋新词强说愁的感觉。

7、拆分循环

之前说道函数时，讲到函数最好只做一件事，如果做了两件事，那么调整这个函数、修改这个函数时我们就要理解两件事，而不是仅仅一件事。

循环也一样，最好只做一件事，有些人为了图方便，用一个循环做多件事，比如一个循环统计一个学生的年龄综合和分数综合。

书中的建议是分成两个循环分别统计，怎么说，说不上好和坏，看选择吧。


8、以管道取代循环


首先搞清楚管道的概念，这里管道概念几乎和linux中管道的概念一模一样。

举个例子linux中的shell命令： ls -al | xargs find ./ -name aaa | xargs grep -rns "hello"

其中的 "|" 就是管道符，它的作用是将前一个命令的输出结果，当做下一个命令的输入内容。

在现代的编程语言中，有相当多的语言机制也可以做到类似的效果，以C++为例最明显就是cout。

eg：cout << "123" << "456" << 789 << endl;

每个<<都是operator<<重载，它的输入类型和输出类型都是ostream类型，从而可以连续的调用<<符合。

这样说可能不是特别明白，再举个例子：一个map算法它的输入是一个集合，执行的是A操作，它的输出还是一个集合，

另个一个filter算法，它的输入也是一个集合，那么map算法的输出就可以当做filter算法的输入，从而达到管道的效果。

从逻辑上就是：一个集合流，先经过A操作，再经过B操作，最后输出的还是一个集合，入下图所示：



通常，我们需要迭代处理一个集合时，常规的做法是通过循环遍历集合，然后再循环的内部执行处理的逻辑。

但是更加现代的做法是通过“集合管道算法”来代替循环，这样不仅更加方法、更加安全、可读性更强，集合的处理流程一目了然。

这里要插一句，可读性强的前提是阅读者要熟悉“集合管道算法”，如果都没听过这种算法，那么它可能压根就看不懂管道代替循环的写法。

他甚至会为了他理解的可读性，人为把管道写法替换为循环。

但是不可否定的，某些场景下，管道代替循环确实是一种更加高级、更加现代的方法，值得推荐。

9、移除死代码

死代码是指永远有也运行不到的代码，通常有些不用的代码我们会先注释掉，这样在代码中可能会经常看到大段大段的注释。

在没有版本管理之前，注释当前用不到，但是将来非常可能用到的代码确实是合理的。

但是在现在版本管理工具非常成熟的年代，完全可以将它删除掉，git msg中做个标记，将来用到时，再从历史版本中获取即可。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

这一章节让我收获最多是第8小结，以管道代替循环，确实让我眼前一亮。

其他的搬移手法，都是换汤不换药，本质都是一回事：将联系紧密代码元素放置在一起。
